;; Cons
(define (make-machine ops controller-text)
  (let ((machine (make-new-machine)))
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (flist (flist-make))
        (alist (alist-make))
        (inst-count 0)
        (trace-inst false)
        (curr-label-name false)
        (curr-label-index 1)
        (breakpoints '()))
    (let ((the-ops
           (list (list 'print print)
                 (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val (cadr val)
              (error "Unknown register: " name))))
      (define (trace-print inst)
        (when trace-inst
          (print (instruction-label inst)
                 (instruction-text inst))))
      (define (breakpoint-iter inst)
        (if (member (instruction-text-type (instruction-text inst))
                    '(branch goto))
            (begin
              (set! curr-label-name (instruction-label inst))
              (set! curr-label-index 1))
            (set! curr-label-index (1+ curr-label-index))))
      (define (breakpoint-check inst)
        (let ((curr-point (list curr-label-name curr-label-index))
               (break (lambda (curr-point)
                        (print 'breakpoint curr-point)
                        (set! curr-label-index (1+ curr-label-index))))
               (next (lambda ()
                       (breakpoint-iter inst)
                       (trace-print inst)
                       ((instruction-execution-proc inst))
                       (execute))))
          (if (member curr-point breakpoints)
              (break curr-point)
              (next))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts) 'done
              (breakpoint-check (car insts)))))
      (define (dispatch m)
        (cond ((eq? m 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? m 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? m 'allocate-register) allocate-register)
              ((eq? m 'get-register) lookup-register)
              ((eq? m 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? m 'stack) stack)
              ((eq? m 'operations) the-ops)
              ((eq? m 'flist) flist)
              ((eq? m 'alist) alist)
              ((eq? m 'data-path-dot)
               (lambda (opts) (data-path-dot flist alist opts)))
              ((eq? m 'inst-count-reset)
               (set! inst-count 0))
              ((eq? m 'inst-count) inst-count)
              ((eq? m 'trace-on)
               (set! trace-inst true))
              ((eq? m 'trace-off)
               (for-each (lambda (register) (register 'trace-off))
                         (map cadr register-table))
               (set! trace-inst false))
              ((eq? m 'register-trace-on)
               (lambda (name)
                 ((lookup-register name) 'trace-on)
                 'ok))
              ((eq? m 'register-trace-off)
               (lambda (name)
                 ((lookup-register name) 'trace-off)
                 'ok))
              ((eq? m 'breakpoint-set)
               (lambda (label n)
                 (set! breakpoints (cons (list label n)
                                         breakpoints))
                 'ok))
              ((eq? m 'proceed)
               (execute))
              ((eq? m 'breakpoint-cancel)
               (lambda (label n)
                 (set! breakpoints (delete (list label n)
                                           breakpoints))
                 'ok))
              ((eq? m 'breakpoint-cancel-all)
               (set! breakpoints '())
               'ok)
              ((eq? m 'breakpoints) breakpoints)
              (else
               (error "Unknown request -- MACHINE" m))))
      dispatch)))
;; Interface
(define (start machine)
  (machine 'start))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
(define (data-path machine . opts)
  ((machine 'data-path-dot) opts))
(define (set-breakpoint machine label n)
  ((machine 'breakpoint-set) label n))
(define (proceed-machine machine)
  (machine 'proceed))
(define (cancel-breakpoint machine label n)
  ((machine 'breakpoint-cancel) label n))
(define (cancel-all-breakpoints machine)
  (machine 'breakpoint-cancel-all))
