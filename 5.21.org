* Question
:PROPERTIES:
:header-args:scheme: :eval no
:END:
Implement register machines for the following procedures. Assume that the list-structure memory operations are available as machine primitives.

a. Recursive ~count-leaves~:

#+begin_src scheme
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
#+end_src

b. Recursive ~count-leaves~ with explicit counter:

#+begin_src scheme
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
#+end_src

* Answer
** a. Recursive ~count-leaves~
Not having implementing the register-specific stack offered by Ex 5.11.c means that the order of stack executions here matters! We make careful use of the stack to mimick the different recursive states of the procedure: ~left~ pushes ~continue~ and ~sexp~, ~right~ pops ~sexp~ and pushes ~val~, ~combine~ pops ~val~, and ~next~ pops ~continue~.

#+begin_src scheme :results output
  (load "5.19.register-machine.scm")
  (let ((inst '(init
                (assign continue (label done))
                ;; Test recursion
                main
                (test (op null?) (reg sexp))
                (branch (label null))
                (test (op pair?) (reg sexp))
                (branch (label left))
                (goto (label leaf))
                ;; Empty element = 0
                null
                (assign val (const 0))
                (goto (reg continue))
                ;; Leaf element = 1
                leaf
                (assign val (const 1))
                (goto (reg continue))
                ;; Process left node
                left
                (save continue)
                (save sexp)
                (assign continue (label right))
                (assign sexp (op car) (reg sexp))
                (goto (label main))
                ;; Process right node
                right
                (restore sexp)
                (save val)
                (assign continue (label combine))
                (assign sexp (op cdr) (reg sexp))
                (goto (label main))
                ;; Combine results
                combine
                (assign cur (reg val))
                (restore val)
                (assign val (op +) (reg val) (reg cur))
                (goto (label next))
                ;; Continue to next step
                next
                (restore continue)
                (goto (reg continue))
                ;; Finished
                done)))
    (let ((sexp '((1 2) 3 4))
          (mach (make-machine
                 (list (list 'null? null?)
                       (list 'pair? pair?)
                       (list 'car car)
                       (list 'cdr cdr)
                       (list '+ +))
                 inst)))
      ((mach 'register-trace-on) 'sexp)
      ((mach 'register-trace-on) 'val)
      (set-register-contents! mach 'sexp sexp)
      (start mach)))
#+end_src

#+RESULTS:
#+begin_example

reg sexp *unassigned* to ((1 2) 3 4)
reg sexp ((1 2) 3 4) to (1 2)
reg sexp (1 2) to 1
reg val *unassigned* to 1
reg sexp 1 to (1 2)
reg sexp (1 2) to (2)
reg sexp (2) to 2
reg val 1 to 1
reg sexp 2 to (2)
reg sexp (2) to ()
reg val 1 to 0
reg val 0 to 1
reg val 1 to 1
reg val 1 to 1
reg val 1 to 2
reg sexp () to ((1 2) 3 4)
reg sexp ((1 2) 3 4) to (3 4)
reg sexp (3 4) to 3
reg val 2 to 1
reg sexp 3 to (3 4)
reg sexp (3 4) to (4)
reg sexp (4) to 4
reg val 1 to 1
reg sexp 4 to (4)
reg sexp (4) to ()
reg val 1 to 0
reg val 0 to 1
reg val 1 to 1
reg val 1 to 1
reg val 1 to 2
reg val 2 to 2
reg val 2 to 4
#+end_example

** b. Iterative ~count-leaves~
Iterating across the data structure reduces the stack operations considerably.

#+begin_src scheme :results output
  (load "5.19.register-machine.scm")
  (let* ((inst '(init
                 (assign continue (label done))
                 (assign val (const 0))
                 ;; Test recursion
                 main
                 (test (op null?) (reg sexp))
                 (branch (label null))
                 (test (op pair?) (reg sexp))
                 (branch (label left))
                 (goto (label leaf))
                 ;; Empty element = 0
                 null
                 (goto (reg continue))
                 ;; Leaf element = 1
                 leaf
                 (assign val (op +) (reg val) (const 1))
                 (goto (reg continue))
                 ;; Process left node
                 left
                 (save continue)
                 (save sexp)
                 (assign continue (label right))
                 (assign sexp (op car) (reg sexp))
                 (goto (label main))
                 ;; Process right node
                 right
                 (restore sexp)
                 (restore continue)
                 (assign sexp (op cdr) (reg sexp))
                 (goto (label main))
                 ;; Finished
                 done)))
         (let ((sexp '((1 2) 3 4))
               (mach (make-machine
                      (list (list 'null? null?)
                            (list 'pair? pair?)
                            (list 'car car)
                            (list 'cdr cdr)
                            (list '+ +))
                      inst)))
           ((mach 'register-trace-on) 'sexp)
           ((mach 'register-trace-on) 'val)
           (set-register-contents! mach 'sexp sexp)
           (start mach)))
#+end_src

#+RESULTS:
#+begin_example

reg sexp *unassigned* to ((1 2) 3 4)
reg val *unassigned* to 0
reg sexp ((1 2) 3 4) to (1 2)
reg sexp (1 2) to 1
reg val 0 to 1
reg sexp 1 to (1 2)
reg sexp (1 2) to (2)
reg sexp (2) to 2
reg val 1 to 2
reg sexp 2 to (2)
reg sexp (2) to ()
reg sexp () to ((1 2) 3 4)
reg sexp ((1 2) 3 4) to (3 4)
reg sexp (3 4) to 3
reg val 2 to 3
reg sexp 3 to (3 4)
reg sexp (3 4) to (4)
reg sexp (4) to 4
reg val 3 to 4
reg sexp 4 to (4)
reg sexp (4) to ()
#+end_example
