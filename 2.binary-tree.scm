;; Sel
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
;; Cons
(define (make-tree entry left right)
  (list entry left right))
;; Helper (Ex 2.63 and 2.64)
(define (tree->list tree)
  (let copy-to-list ((tree tree)
                     (result-list '()))
    (if (null? tree)
      result-list
      (copy-to-list (left-branch tree)
                    (cons (entry tree)
                          (copy-to-list (right-branch tree)
                                        result-list))))))
(define (list->tree elements)
  (car
    (let partial-tree ((elts elements)
                       (n (length elements)))
      (if (= n 0)
        (cons '() elts)
        (let* ((left-elts elts)
               (left-size (quotient (- n 1) 2))
               (left-result (partial-tree elts left-size))
               (left-tree (car left-result))
               (non-left-elts (cdr left-result))
               (this-entry (car non-left-elts))
               (right-elts (cdr non-left-elts))
               (right-size (- n (+ left-size 1)))
               (right-result (partial-tree right-elts right-size))
               (right-tree (car right-result))
               (remaining-elts (cdr right-result)))
          (cons (make-tree this-entry left-tree right-tree)
                remaining-elts))))))
