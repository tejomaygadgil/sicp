(define (apply-generic op . args)
  (define (no-drop? op) (get 'no-drop op))
  (define (raise-to source target)
    (let ((target-type (type-tag target)))
      (let iter ((source source))
        (let ((raised (raise source)))
          (if (not-found? raised) false
            (let ((raised-type (type-tag raised)))
              (cond ((equal? raised-type target-type) raised)
                    (raised (iter raised)))))))))
  (define (drop arg)
    (let ((projected (project arg)))
      (if (and (not (not-found? projected))
               (equ? arg (raise projected)))
        (drop projected)
        arg)))
  (define (raise-binary op args)
    (let ((arg1 (car args))
          (arg2 (cadr args)))
      (if (equal? (type-tag arg1)
                  (type-tag arg2)) ; (*)
        (let ((raised1 (raise arg1))
              (raised2 (raise arg2)))
          (if (false? raised1) raised1
            (apply-generic op raised1 raised2)))
        (let ((raise1 (raise-to arg1 arg2)))
          (if raise1 (apply-generic op raise1 arg2)
            (let ((raise2 (raise-to arg2 arg1)))
              (if raise2 (apply-generic op arg1 raise2)
                'not-found)))))))
  (define (raise-unary op args)
    (let* ((arg (car args))
           (raised (raise arg)))
      (if (false? raised) raised
        (apply-generic op raised))))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (let ((result (apply proc (map contents args))))
          (if (no-drop? op) result
            (drop result)))
        (cond ((= (length args) 2)
               (raise-binary op args))
              ((and (= (length args) 1) ; (*)
                    (not (equal? op 'raise))
                    (not (equal? op 'project)))
               (raise-unary op args))
              (else 'not-found))))))
